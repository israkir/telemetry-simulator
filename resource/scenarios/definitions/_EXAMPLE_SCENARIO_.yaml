# =============================================================================
# Example / reference scenario: all available configs and settings
# =============================================================================
# Config files (project paths):
#   resource/config/config.yaml  – IDs, workflows, latency, control-plane, conversation samples
#   resource/config/resource.yaml – OTEL resource attributes (service.name, schema_url, etc.)
#
# resource/config/config.yaml sections used by scenarios:
#   id_formats          – session_id, conversation_id, request_id, mcp_tool_call_id, enduser_pseudo_id (placeholders: {hex:N}, {uuid}, {tenant_id})
#   tenants             – context.tenant key → id (e.g. toro)
#   agents              – context.agent id (e.g. toro-customer-assistant-001); must match a2a.agent.target.id
#   mcp_servers         – context.mcp_server key → mcp_server_uuid + tools (name, tool_uuid)
#   tool_call_arguments – optional; keyed by tool name → JSON object for gen_ai.tool.call.arguments
#   scenarios           – divisions, error_templates (goal → error_type, http_status_codes), workflow_templates (workflow name → step list)
#   latency_profiles    – <profile>.spans (a2a_orchestrate, planner, mcp_tool_execute, etc.) with mean_ms, variance; scenario sets data_plane.latency_profile
#   control_plane      – trace_flow, request_validation_templates, request_scenarios, latencies_ms
#   conversation_samples – per workflow key; used when scenario has no conversation.samples/turns
#   mcp_retry           – retry_policy, latency_by_error_type; used when building MCP attempt spans
#   mcp_retry_templates – named templates (e.g. retry_then_success); scenario data_plane.mcp_retry can reference by name or define attempts inline
#   tools_recommend     – step_outcome, selection_strategy, etc. for tools.recommend span
#
# resource/config/resource.yaml:
#   schema_url, control_plane.attributes, data_plane.attributes (service.name, service.version, deployment.environment.name, module, component, otel.source).
#   Data-plane component is set per span at runtime (orchestrator, planning, llm, mcp_client, tool_recommender).
#
# Run: otelsim scenario --name _EXAMPLE_SCENARIO_  (excluded from list and mixed workload; reference only).
# =============================================================================

name: _EXAMPLE_SCENARIO_
description: >
  Reference scenario showing every supported YAML option.
  Use as template; adjust for data-plane, control-plane, or mixed.

# Tags for filtering: otelsim run --tags=data-plane,control-plane,multi-turn,example
tags:
  - example
  - data-plane
  - happy-path

# Relative weight when running mixed workload (default 1.0).
# Used only for "otelsim run" (mixed workload): each request picks a scenario at random with
# probability proportional to weight. E.g. scenario A=5, B=1, C=0.5 → over 100 runs you get
# roughly 77 A, 15 B, 8 C (5 : 1 : 0.5). Use higher weight for common paths (e.g. happy_path 5.0)
# and lower for rare outcomes (e.g. policy_error 0.5) so generated traffic looks realistic.
# Not in config.yaml; per-scenario only.
# Baseline weight for examples; other scenarios use relative weights for realistic mix.
workload_weight: 1.0

# MCP server key; UUID resolved from resource/config/config.yaml → mcp_servers.<key>.
# Required for data-plane; control-plane-only can omit or set for registry.
mcp_server: phone

# Run behavior
repeat_count: 2
interval_ms: 100
# Optional: randomize delay; delay = max(0, interval_ms + uniform(-interval_deviation_ms, +interval_deviation_ms))
interval_deviation_ms: 50

emit_metrics: false
emit_logs: false

# Redaction level for gen_ai.input.redacted / gen_ai.output.redacted (none | basic | strict).
# When not "none", use conversation.samples[].user_input_redacted / llm_response_redacted if set.
redaction_applied: none

# -----------------------------------------------------------------------------
# Data-plane (a2a.orchestrate hierarchy: planner, task, tools_recommend, tool, response_compose)
# All keys reference resource/config/config.yaml.
# -----------------------------------------------------------------------------
data_plane:
  # Workflow key → step list from resource/config/config.yaml → scenarios.workflow_templates
  # Example keys: new_claim, update_appointment, claim_status, pay (see config for full list).
  workflow: new_claim
  # Goal and latency_profile must align (happy_path ↔ happy_path, higher_latency ↔ higher_latency).
  goal: happy_path
  latency_profile: happy_path
  # Optional: MCP retry template name (resource/config/config.yaml → mcp_retry_templates) or inline { attempts: [{ outcome, optional error_type, optional latency_mean_ms }] }
  # mcp_retry: retry_then_success
  # Optional: when latency_profile is higher_latency, condition (e.g. peak_hours, zip_code) for span attributes
  # higher_latency_condition: { reason: "peak_hours" }
  # Which request-validation outcome to assume (allowed | blocked | error).
  # Used when trace_flow includes incoming_validation; template from resource/config/config.yaml → control_plane.request_validation_templates.
  control_plane_template: allowed

# Expected MCP server and tools (keys only; UUIDs resolved from resource/config/config.yaml → mcp_servers.<mcp_server>.tools).
# Must match data_plane.workflow tool steps (e.g. new_claim → tools: [new_claim]).
expected:
  mcp_server: phone
  tools:
    - new_claim

# -----------------------------------------------------------------------------
# Conversation: single-turn (samples) OR multi-turn (turns)
# - If neither: resource/config/config.yaml → conversation_samples[data_plane.workflow] is used (one random sample per iteration).
# - samples: one random sample per iteration; optional user_input_redacted / llm_response_redacted when redaction_applied != none.
# - turns: multi-turn; one trace per turn, same session_id; optional redacted per turn.
# - cycle_conversation_samples: when true and samples set, use (iteration_index % len(samples)) so each run cycles through all.
# -----------------------------------------------------------------------------
conversation:
  samples:
    - user_input: "I want to start a claim for my phone."
      llm_response: "I've started a claim (PH-8842). Describe what happened and I'll get you an appointment."
    # When redaction_applied != none, redacted text used for gen_ai.input.redacted / gen_ai.output.redacted:
    - user_input: "Start a claim. My address is 42 High Street and policy POL-8892."
      llm_response: "I've started a claim at 42 High Street under policy POL-8892. Claim ID PH-9900."
      user_input_redacted: "Start a claim. My address is <ADDRESS> and policy <POLICY_ID>."
      llm_response_redacted: "I've started a claim at <ADDRESS> under policy <POLICY_ID>. Claim ID PH-9900."

# -----------------------------------------------------------------------------
# Context: keys only; IDs from resource/config/config.yaml
# -----------------------------------------------------------------------------
# - tenant: resource/config/config.yaml → tenants.<key> (e.g. toro)
# - agent: resource/config/config.yaml → agents[].id (e.g. toro-customer-assistant-001); must match a2a.agent.target.id
# - mcp_server: resource/config/config.yaml → mcp_servers.<key> (mcp_server_uuid + tools with name, tool_uuid)
# Optional (advanced): workflow, correct_flow.steps, error_pattern, redaction_applied, error_config, actual_steps (partial_workflow)
context:
  tenant: toro
  agent: toro-customer-assistant-001
  mcp_server: phone

# -----------------------------------------------------------------------------
# Control-plane (optional in this file)
# Use for control-plane-only scenarios (no data_plane.workflow) or to override.
# Templates: resource/config/config.yaml → control_plane.request_validation_templates
# (e.g. allowed, allowed_but_flagged, blocked_rate_limited, blocked_request_policy, error_policy_runtime).
# Registry: control_plane.request_scenarios (name → template + description) for built-in control-plane scenarios.
# -----------------------------------------------------------------------------
# control_plane:
#   # Option A: explicit template id (overrides outcome/block_reason)
#   template: allowed_but_flagged
#   # Option B: outcome + block_reason (template resolved by loader)
#   # request_outcome: blocked
#   # block_reason: invalid_payload
#   # Optional: override policy span exception from template
#   # policy_exception: { type: "PolicyEngineTimeout", message: "policy_engine_timeout" }

# -----------------------------------------------------------------------------
# Scenario overrides (optional; for goal != happy_path)
# resource/config/config.yaml → scenarios.error_templates, scenarios.divisions
# For goal: 4xx_invalid_arguments, set exception_type and exception_message so the
# failing MCP attempt records a concrete exception event (not generic "Error occurred").
# -----------------------------------------------------------------------------
# scenario_overrides:
#   exception_type: "InvalidArgumentsError"   # For 4xx_invalid_arguments (e.g. claim ID or date format)
#   exception_message: "Invalid or missing parameters."
#   step_index_for_4xx: 0        # Which MCP step gets 4xx (for 4xx_invalid_arguments)
#   wrong_division_target: electronics   # Division key for wrong_division
#   actual_steps: [planner, task, new_claim, response_compose]  # For partial_workflow
#   skip_steps: [2]              # Or drop step indices from correct_flow (partial_workflow)

# -----------------------------------------------------------------------------
# Minimal control-plane-only example (no data_plane, no mcp_server required in context):
#   name: request_allowed_audit_flagged
#   tags: [control-plane]
#   control_plane:
#     template: allowed_but_flagged   # config → control_plane.request_validation_templates
#   context:
#     tenant: toro
#     agent: toro-customer-assistant-001
# See definitions/request_allowed_audit_flagged.yaml and resource/config/config.yaml → control_plane.request_scenarios.
# -----------------------------------------------------------------------------
